## 1.计算机系统IO模型

#### 1.阻塞IO

当用户的一个工作线程，建立一个IO管道去进行相应的读写操作时，如果没有数据一直没有准备好，内核（系统）一直等待,导致用户工作线程一直等待，不执行下一步，那么此时就是阻塞的.



####2.非阻塞IO

当用户的一个工作线程，建立一个IO管道去进行相应的读写操作时，内核（系统）明确的返回有或者无，用户工作线程可以明确的得到操作系统的结果.如果返回无,用户工作线程循环再次请求IO，直至得到操作系统返回一个有的结果.此时就是非阻塞的.



#### 3.IO复用

可以对多个IO端口进行监听。	

select: 一次性将所有要监听的IO端口列表传入系统内核，如果有返回结果再将所有列表返回给系统内核

epoll:第一个IO请求时，会将所有要监听的IO端口列表传入系统内核epoll文件,且建立相应的socket，

epoll文件有个共享区域，此区域工作线程和系统内核共享.因此系统内核如果得到相应的结果后，直接先更新共享区域内的列表(红黑树结构)，再更新对应工作线程对应共享内存的列表（列表结构）。省去了后续列表的复制，遍历过程.



####4.异步IO

用户工作线程，请求IO操作时，建立另外一个线程去等待数据的到来，当前工作线程继续执行下一步操作，后续另外一个线程通过回调函数的形式通知当前线程数据的到来.























多线程下CPU 与内存的交互:为保持数据的一致性.Intel CPU采用两种方式保证多线程下操纵共享数据的一致性.

1. CPU总线锁 直接锁住总线。一次只能一个CPU与内存中的共享变量进行交互。效率极差.  
2. 缓存锁即缓存一致性原理。CPU缓存一次存入8个字节的数据。（局部性效率原理)  
	当CPU1 访问共享变量时，共享变量复制到CPU1的缓存行中去 此时CPU1中的变量状态为E独占。
	此时CPU2也需要访问共享变量，总线嗅探机制会将CPU1中变量的状态变为S共享。并且复制一份变量到CPU2的缓存中去。此时CPU2的变量状态也为S。
	一旦CPU1修改变量。则CPU1的变量则会变为M，此时总线嗅探机制会将CPU2的变量状态变为I。并且此时CPU2无权将变量A写回到主内存当中去。
	CPU1修改完变量。将自己的变量状态改为E并且写入到主内存当中去。总线嗅探机制会将CPU1的改动通知到CPU2。CPU2重新加载变量，之后将两个变量的状态修改为S。





