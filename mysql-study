





## 1.MySQL执行计划

#### 1. explain +SQL  显示SQL的执行计划

1. id

	id相同，说明是同一级查询，从上往下，依次执行。

	id不同, id越大说明查询的优先级越高

	id相同不同的混合。 id相同的可以认为一组，从上往下，依次执行。

	id不同的，id越大,查询的优先级越高。

	

2. type: 查询的类型

1. simple:简单查询 
2.  primary 查询中包含任何复杂的子查询，最外层查询被标记为primary
3. union 第一个select 紧跟union  ,union之后的select被标记为union
4. dependt union  union后select的结果会受 union或unionAll的影响
5. subquery  select或者where条件中包含子查询

   6 dependent subquery  子查询会受到外部select的影响

   7.delivered  from当中派生出来的查询

   8.uncacheable  subquery  子查询的结果不能被缓存





3. table 

	单一数字 实际存在的表名

	deliver 数字 id为几的子查询表

	union(2,3)  union查询 id 为几到几的表

	

4. type 访问类型

	1. All  全表扫描，一行一行的去查找
	2. index 全索引扫描
	3. range  限制了索引的范围
	4. index subquery 利用子查询 关联到了索引
	5. unique subquery 与子查询关联索引类似但使用的是唯一索引
	6. ref   or null  关联条件  为 is  null   or e.id=3333;
	7. ref  使用非唯一性索引进行查找
	8. eq_ref  使用唯一性索引进行查找
	9. const 这个表中匹配至多只有一行





5.possible_keys

查询过程中涉及到字段若存在索引，将被列出，但实际不一定会被使用到

6.key 

实际使用的索引，没有则为null   如果有，则和slect

7.key_len

索引使用的字节长度	，不损失精度的情况下，长度越短越好

8.ref 

索引的哪一列被使用到了

9.rows

查询过程中，实际查找的表数据记录数，越短越好.

10.extra

包含的额外信息





## 2.MYSQL索引

### 1.MYSQL索引使用的数据结构B+树

1. 为什么不使用hash

	如果发生hash碰撞的次数较多，那么hash桶里面的链表可能过长，导致查询数据时，要遍历这个很长的链表，导致查询效率变低.

	如果是等值查询，hash确实能快速查询出对应的数据，但是如果是范围查询，因为hash表的存储是无序的，那么就需要将hash表里所有的数据全部加载到内存，遍历比较。这样大大占用了内存空间.

2. 为什么不使用二叉树

	二叉树虽然有序。但是如果数据的顺序分布不均匀，导致某一边存在非常的链表的话，那么查出是依然要遍历这个很长的链表，影响效率

3. 为什么不是用平衡树，红黑树

	平衡树，红黑树虽然保证了不会出现超长的链表，但是数据的节点依然很深，这样查询数据时，依然要遍历很多树的节点。会造成IO次数的过多，影响读取效率

4. 为社么不使用B树

	B树每个数据块能存储好几个节点的数据，所以一次IO就能读取很多节点的数据，这样大大减少了IO次数。但是由于B树中的数据块也会存储数据，导致存放的节点很少。3次IO能读取16 * 16 * 16的数据。

	但是如果是千万级别的数据，依然要造成较高次数的IO

5. 为什么使用B+树

	B+树与B树的数据结构一样，唯一不同的是B+树的树干不存储实际数据，只有最底层的树叶才会存储数据。树干只存储节点，这样就能存储非常多的节点。3次IO就能读取 160 * 160 *  16的数据 这样也能支持千万级别的数据了。

### 1.索引的分类

1. 主键索引 唯一，非空
2. 唯一索引
3. 普通索引
4. 联合索引
5. 全文索引 适用于varchar char text clob



### 3.索引的优点

1. 大大减少需要扫描的数据量，减少IO次数，与IO流量

2. ？

3. 随机IO变为顺序IO

	随机IO：数据存放在任意磁盘页上。

	顺序IO：数据连续存放在同一个磁盘页上或者临近的磁盘页上

	顺序比随机IO快10倍

	MYSQL使用B+树存储数据索引,存放数据时会将数据存放在连续的4页上16KB

	MYSQL使用索引查询数据时，也会根据索引查询连续的磁页。避免了查询多余的磁页的过程



## 4.专业术语

#### 1.回表

由于MySQL使用B+树,非主键索引的最底层树叶存储是该表的主键值。所以如果查询的是索引列，主键列之外的列的话，那么会根据索引的主键值，再去主键索引中查询对应的实际数据.

```SQL 
SELECT * FROM A WHERE NAME ='1'; -- 会进行回表
SELECT id,NAME FROM A WHERE NAME ='1';--不会进行回表
```



### 2.覆盖索引

只在一颗 索引树上进行查找匹配。

```sql 
SELECT id,NAME FROM A WHERE NAME ='1';--覆盖索引s
```

好处：1.大大减少数据的访问量，提高性能

​            2.因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多

​            

### 3.最左匹配

(name,age)联合索引

```SQL 
SELECT * FROM A WHERE NAME ='1' AND AGE=18;--满足最左匹配原则
SELECT * FROM A WHERE  AGE=18 ;--不满足最左匹配原则,不会匹配索引
```

解决方案 

1. 为AGE列单独建立一个索引
2. 修改联合索引为(age,name)



### 4.索引下推

1. MySQL5.6之前  根据联合索引  （name,age) 查询出id，第一次回表，根据name='1' 查出的id进行数据查询，查询出对应name='1' id 的数据,此时MYSQL-server拿到对应的数据，再根据age=18的id,再进行第二次回表 



2. MYSQL5.6之后 根据索引name='1'，age='18'  查找出符合条件的id ,再根据id 回表查询出数据。只用了一次回表

```SQL 
SELECT * FROM A WHERE NAME ='1' AND AGE=18;--回表两次 5.6之前
SELECT * FROM A WHERE NAME ='1' AND AGE=18;--回表一次 5.6之后
```







## 5.索引的匹配方式 

idx_nap` (`name`,`age`,`pos`)

#### 1.全值匹配

```SQL 
explain select * from staffs where name = 'July' and age = '23' and pos = 'dev';
```

#### 2.匹配最左前缀

联合索引会按创建索引顺序，从左到右，依次 获取索引值，如果过滤条件缺少某一列，那么索引只会取已经获取到的列

```SQL  
explain select * from staffs where name = 'July' and age = '23';--匹配了索引 name,age
explain select * from staffs where name = 'July' and pos = '23';--匹配了索引name
```

#### 3匹配列前缀

如果使用模糊查询，那么如果值开头，那么可以匹配到索引。否则匹配不上索引

```SQL 
explain select * from staffs where name like 'J%'; -- 匹配了索引name
explain select * from staffs where name like '%J%'; -- 未匹配索引name
```



#### 4.匹配范围值

索引可以进行范围匹配

```SQL  
explain select * from staffs where name > 'Mary'; 
```



####5.某一索引精确匹配，另一索引范围匹配

```SQL 
explain select * from staffs where name = 'July' and age > 25;
```



#### 6.只访问索引的行

select 索引字段  不需要再进行回表。第二次查询

```sql 
explain select name,age,pos from staffs where name = 'July' and age = 25 and pos = 'dev';
```



## 6.优化小细节

actor_id  主键索引

#### 1.尽量不要将索引列使用表达式计算

```sql 
select actor_id from actor where actor_id=5 --索引
select actor_id from actor where actor_id+1=5  --无索引
```



#### 2.尽量使用主键查询，这样可以有效避免回表



#### 3.使用前缀索引

前缀索引取某一列的前几个字符作为索引

好处：防止索引字段如果过长，有利于构建索引，节省空间

坏处：重复性如果过多，查找起不到索引的作用，降低了索引的选择性

```SQL 
-- 字段 aadsfafasfasadedafsdafafd
-- 前缀索引区该列的前几位 这样就能减少空间
```

解决方案:取这一列的倒数一两位为前缀索引的结束字段，这样既大大发挥了前缀索引的长度，也只在很小程度上降低了索引的选择性

#### 4.排序时尽量使用索引

UNIQUE KEY `rental_date` (`rental_date`,`inventory_id`,`customer_id`)

1. 排序时，联合索引的左列作为精确查询条件 之后排序使用联合索引的右列，那么排序时会使用到联合索引来排序

2. 排序时，联合索引的左列作为范围查询条件 之后排序使用联合索引的右列，那么排序时不会使用联合索引来排序
3. 索引使用升序排列，排序时有一个排序与其他排序不一致，那么也不会使用索引排序
4. 排序列中使用了一个不在联合索引之内的列，那么也不会使用索引排序

```SQL 
explain select rental_id,staff_id from rental where rental_date='2005-05-25' order by inventory_id,customer_id\G;


explain select rental_id,staff_id from rental where rental_date='2005-05-25' order by inventory_id desc\G

explain select rental_id,staff_id from rental where rental_date>'2005-05-25' order by rental_date,inventory_id\G

explain select rental_id,staff_id from rental where rental_date>'2005-05-25' order by inventory_id desc,customer_id asc\G

explain select rental_id,staff_id from rental where rental_date>'2005-05-25' order by inventory_id,staff_id\G

```



####5.union all   in  or  都可以使用索引，但是建议使用 in

1. or会产生多个条件判断
2. in直接范围查找
3. union all实际会一条一条关联



####6.范围列（> ,<）可以用到索引  但不连续范围索引





#### 7.强制类型转换会导致索引失效

数据库是数字类型 =字符类型  mysql自动发生类型转换，导致索引失效



#### 8.频繁更新的列不适宜作为索引，列的重复性过高也不适宜作为索引

一般区分在80%以上就能建立索引 count(distinct(column))/count(\*)统计所占比例





#### 9.建索引的列不应该为null



#### 10.当进行连接查询时，连接的表最好不要超过3张。并且数据类型必须一致



#### 11.能使用limit的尽量使用limit，limit会尽量减少扫描的范围



#### 12.单表索引建议保证在5个左右，索引过多，导致索引文件过大，同样会增大IO量。



#### 13.联合索引的字段不适宜超过5个



#### 14.避免索引越多越好的概念，以及在无了解实际情况的下，盲目优化.



## 7.索引监控

show status like '%Handler_read%';

#### 1.Handler_read_first

读取索引第一个条目次数

#### 2.Handler_read_key

通过索引获取数据数

#### 3.Handler_read_last

读取索引最后一个条目次数

#### 4.Handler_read_next

通过索引读取下一条数据的次数

#### 5.Hanler_read_pre

通过索引读取上一条数据的次数

#### 6.Handler_read_rnd

从固定位置读取数据的次数

#### 7.Handler_read_rnd_next

从数据节点读取下一条数据的次数





## 8.优化查询

#### 1.查询慢的原因

1. 网络

2. IO

3. CPU

4. 高并发，线程上下文的切换

5. 系统调用

6. 生成统计信息

7. 锁的等待

	---------------------》数据量大，筛选数据量耗时长



 #### 2.排查步骤

1. 分析应用程序是否检索了大量不需要的数据

2. 分析MYSQL 服务器是否检索了大量不需要数据

	

	

#### 3.SQL执行过程的优化

1. 查询缓存 MYSQL8.0之后不再使用

2. 语法解析预处理

3. 查询优化器

	3.1 索引的大小，长度

	show status like 'last_query_cost'; 查询消耗时间成本

	3.2 表统计信息

	3.3 有时mysql会选择错误的执行计划

	3.4 
	
	

4. 优化策略

   4.1 优化count查询  myisam count(**) 会维护一个值，因此查询较count(1)较快,别的没有差别

  4.2  优化关联查询

   4.3 优化子查询

   4.4  优化limit分页

  4.5  优化union查询  如果没有特别要求，尽量使用Unionall  







## 9.MySQL用户自定义变量

####1.设置用户自定义变量

set @one:=1

set @one:=(select id from actor where id=1);



####2.自定义变量注意事项

1. 自定义变量无法使用查询缓存

2. :=的优先级非常低，所以只能使用()提高优先级

3. 使用未定义的自定义变量不会产生语法错误

4. 注意取值，赋值的顺序.可能影响我们的预期结果

	

	```SQL 
	set @rownum:=0;
	select actor_id,@rownum:=@rownum+1 as cnt from actor where @rownum<=1;
	-- 因为where和select在查询的不同阶段执行，所以看到查询到两条记录，这不符合预期
	
	
	set @rownum:=0;
	select actor_id,@rownum:=@rownum+1 as cnt from actor where @rownum<=1 order by first_name
	-- 当引入了order by之后，发现打印出了全部结果，这是因为order by引入了文件排序，而where条件是在文件排序操作之前取值的  
	
	-- 解决这个问题的关键在于让变量的赋值和取值发生在执行查询的同一阶段：
	set @rownum:=0;
	select actor_id,@rownum as cnt from actor where (@rownum:=@rownum+1)<=1;
	
	```

	

	





####3.使用案例

1. 优化排名语句,给变量赋值的同时，使用这个变量

	```SQL 
	select actor_id,@rownum:=@rownum+1 as rownum from actor limit 10;
	
	```



2. 按照一定的条件进行排名

```sql 
select actor_id,count(*) as cnt from film_actor group by actor_id order by cnt desc limit 10;
```



3. 避免查询刚刚更新的数据

	```sql 
	update t1 set  lastUpdated=now() where id =1;
	select lastUpdated from t1 where id =1;
	
	-- 用自定义变量 方便效率高
	update t1 set lastupdated = now() where id = 1 and @now:=now();
	select @now;
	```

	

















































===========================================MYSQL设置新密码=======================================================================
1，mysqld --console --skip-grant-tables --shared-memory //开启无密码登录MYSQL服务模式,
2，update user set authentication_string='' where user='root';
3，ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码'; //5.7.5以后
4，set password for root@localhost=password('');//5.7.5以前
============================================MYSQL navicate not support authorication======================================================================
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';



============================================MYSQL不同引擎数据库文件存储======================================================================
了解MYSQL的都知道，在MYSQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的.frm文件,.frm文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，.frm文件跟数据库存储引擎无关，也就是任何存储引擎的数据表都必须有.frm文件，命名方式为数据表名.frm，如user.frm. .frm文件可以用来在数据库崩溃时恢复表结构。

MySQL文件包括MySQL所建数据库文件和MySQL所用引擎创建的数据库文件。

.frm 文件与操作系统和数据库引擎无关，都有这么个与表名同名文件。

MyISAM引擎的文件：

.myd 即 my data，表数据文件

.myi 即my index，索引文件

.log 日志文件。

InnoDB引擎的文件：

采用表空间（tablespace）来管理数据，存储表数据和索引，

InnoDB数据库文件（即InnoDB文件集，ib-file set）：

ibdata1、ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据和索引，所有表共用。

.ibd文件：单表表空间文件，每个表使用一个表空间文件（file per table），存放用户数据库表数据和索引。

日志文件： ib_logfile1、ib_logfile2

################################################################################################################################################################

Innodb存储引擎管理主要基于两个文件：表空间数据文件和日志文件。

InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。

如果没有指定InnoDB配置选项，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile 1的5MB大小的日志文件。

ibdata1的大小在my.cnf文件中配置：innodb_data_file_path = ibdata1:10G:autoextend

可以设置最大数据文件限制，以免超过系统支持的最大文件：

innodb_data_file_path = ibdata1:100M:autoextend:max:500M

日志文件大小在my.cnf文件中配置：innodb_log_file_size  = 256M  innodb_log_files_in_group = 2

Innodb存储引擎可以使用共享表空间或独立表空间，使用独立表空间时，需要将innodb_file_per_table加到配置文件中，也可以在variables中开启。

共享表空间是将所有的表的数据和索引保存在ibdata1中，这样的缺点是拷贝时必须拷贝整个大文件，而且删除表后容易产生碎片。

独立表空间是为每个表建立一个.ibd文件用来存储数据和.frm用来存数据词典信息，这样，mysql就将innodb表的数据存入各自对应的.ibd文件中了，但结构等信息还是会写入ibdata。

innodb_file_per_table变量只能在配置文件里修改，不能使用set global ...

将innodb_file_per_table关闭之后，建立innoDB表时只生成.frm文件，数据和索引都保存在共享表空间ibdata1中。################################################################################################################################################################

MySQL数据库存放位置：

1、MySQL如果使用MyISAM存储引擎，数据库文件类型就包括.frm、.MYD、.MYI，默认存放位置是C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data

2、MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1、.ibd，存放位置有两个，

.frm文件默认存放位置是C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data，ibdata1、.ibd文件默认存放位置是MySQL安装目录下的data文件夹
========================================================MYSQL导出数据文件命令==========================================================

1. 用 SELECT…INTO OUTFILE 导出文本文件
 在 MySQL 数据库中导出数据时，允许使用包含导出定义的 SELECT 语句进行数据的导出操作。
 该文件在服务器主机上创建，因此必须拥有文件写入权限 (FILE权限)，
 才能使用此语法。“SELECT...INTO OUTFILE 'filename' " 形式的 SELECT语句可以把被选择的行写入一个文件中，filename 不能是一个已经存在的文件。
 SELECT...INTO OUTFILE 语句的基本格式如下:

SELECT columnlist FROM table WHERE condition  INTO OUTFILE 'filename' [OPTION]

--OPTIONS 选项
　　FIELDS TERMINATED BY 'value'
　　FIELDS [OPTIONALLY]  ENCLOSED BY 'value' 
　　FIELDS ESCAPED BY 'value' 
　　LINES STARTING BY 'value'  
　　LINES TERMINATED BY 'value'  
SELECT columnlist FROM table WHERE condition 为查询语句，查询结果返回满足指定条件的一条或多条记录；
INTO OUTFLE 语句的作用就是把 SELECT 语句查询出来的结果导出到名称为 filename 的外部文件中，
[OPTIONS] 为可选参数选项，OPTIONS 部分的语法包括 FIELDS 和 LINES 子句。

  FIELDS TERMINATED BY  'value' 设置字段之间的分隔符可以为单个或多个字符，默认情况下为制表符“\t”。
 FIELDS [OPTIONALLY] ENCLOSED BY 'value' 设置字段的包围字符，只能为单个字符，如果使用了OPTIONALLY 
 则只包括 CHAR 和 VARCHAR 等字符数据字段。
FIELDS ESCAPED BY 'value' 设置如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为“\”。
LINES STARTING BY 'value'  设置每行数据开头的字符，可以为单个或多个字符，默认情况下不使用任何字符。
LINES TERMINATED BY 'value' 设置每行数据结尾的字符，可以为单个或多个字符，默认值为“\n”。
FIELDS 和 LINES 两个子句都是自选的，但是如果两个都被指定了，FIELDS 必须位于 LINES 的前面。

SELECT...INTO OUTFILE 语句可以非常快速地把一个表转储到服务器上。如果想要在服务器主机之外的部分客户主机上创建结果文件，
不能使用 SELECT...INTO OUTFILE 语句。在这种情况下，应该在客户主机上使用 mysql -e “SELECT ... " > file_name 这样的命令，来生成文件。

看看到默认情况下，MySQL 使用制表符“\t”分隔不同的字段，字段没有用其他字符括起来。Windows系统下的回车换行为“\r\n”，默认换行符为“\n”。
默认情况下，如果遇到 NULL 值，将会返回“\N”代表空值，反斜线“\”表示转义字符。如果使用 ESCAPED BY 选项，则N前面为指定的转义字符。

2. 用 mysqldump 命令导出文本文件
使用 mysqldump 工具不仅可以将数据导出为包含 CREATE、INSERT 的 sql 文件，也可以导出为纯文本文件。

Mysqldump 将创建一个包含 CREATE TABLE 语句的 tablename.sql 文件和一个包含其数据的 tablename.txt 文件。

mysqldump 导出文本文件的基本语法格式如下:

mysqldump -T path -u root -p dbname [tables] [OPTIONS]

--OPTION 选项
--fields-terminated-by=value
--fields-enclosed-by=value
--fields-optionally-enclosed-by=value
--fields-escaped-by=value
--lines-terminated-by=value

  只有指定了 -T 参数才可以导出纯文本文件；path 表示导出数据的目录；tables 为指定要导出的表名，如果不指定，将导出数据库 dbname 中所有的表； [ OPTIONS] 为可选参数选项，这些选项需要结合-T 选项使用。

OPTIONS 常见的取值如下:

  --fields-terminated-by=value:设置字段之间的分隔符可以为单个或多个字符，默认情况下为制表符“\t”。
 --fields-enclosed-by=value: 设置字段的包围字符。
 --fields-optionally-enclosed-by=value： 设置字段的包围字符，只能为单个字符，包括 CHAR 和 VARCHAR 等字符数据字段。
  --fields-escaped-by=value： 控制如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为“\”。
 --lines-terminated-by=value：设置每行数据结尾的字符，可以为单个或多个字符，默认值为“\n”。


3. 用 mysql 命令导出文本文件
  相比mysqldump，mysql工具导出的结果可读性更强。

使用 mysql 导出数据文本文件语句的基本格式：

mysql -u root -p --execute= "SELECT 语句" dbname >filename.txt

-execute 选项表示执行该选项后面的语句并退出，后面的语句必须用双引号括起来，dbname 为要导出的数据库名称；
导出的文件中不同列之间使用制表符分隔，第1行包含各字段的名称。
使用 --vertical  参数显示结果。




====================================================MYSQL导入数据文件命令==============================================================

mysql 5.5.7以上不行 必须修改全局变量local_infile=1  还要以mysql --local-file=1 启动

 1.用 LOAD DATA INFILE 导入文本文件
  语法格式如下：

LOAD DATA  INFILE  'filename.txt'  INTO  TABLE   tablename  [OPTIONS]  [IGNORE number LINES]

--OPTIONS 选项
　　FIELDS  TERMINATED  BY  'value'   /*设置字段之间分隔符，单个或多个字符，默认为'\t'*/
　　FIELDS  [OPTIONALLY]  ENCLOSEED BY  'value'  /*设置字段包围分隔符，单个字符*/
　　FIELDS  ESCAPED  BY  'value'     /*如何写入或读取特殊字符，单个字符*/
　　LINES  STARTING BY  'value'     /*每行数据开头的字符，单个或多个*/
　　LINES  TERMINATED  BY  'value'   /*每行数据结尾的字符，单个或多个*/

2.用 mysqlimport 命令导入文本文件
 使用 mysqlimport 可以导入文本文件，并且不需要登录 MySQL 客户端。mysqlimport 命令提供了许多与LOAD DATA INFILE 语句相同的功能。
 使用 mysqlimport 语句需要指定所需的选项、导入的数据库名称以及导入的数据文件的路径和名称。

语法格式如下：

 mysqlimport -u root -p dbname filename.txt [OPTIONS]

 --fields-terminated-by=字符串：设置字符串为字段之间的分隔符，可以为单个或多个字符。默认值为制表符“\t”。
-L, --local：表示从客户端任意路径读取文件导入表中，未设置该选项时，默认只从datadir下同名数据库目录下读取文件导入
--ignore-lines=n：表示可以忽略前n行。
-l, --lock-tables：写入时锁定所有表
-p, --password[=name]：指定用户密码
-u, --user=name：指定登入MySQL用户名
-h, --host=name：指定远程连接的服务器
-c, --columns=name：往表里导入指定字段，如：--columns='Name,Age,Gender'
-C, --compress：在客户端和服务器之间启用压缩传递所有信息

 --OPTION 选项
 --fields-terminated-by=value
 --fields-enclosed-by=value
 --fields-optionally-enclosed-by=value
 --fields-escaped-by=value
 --lines-terminated-by=value
 --ignore-lines=n



  dbname 为导入的表所在的数据库名称。mysqlimport 命令不指定导入数据库的表名称，数据表的名称由导入文件的名称确定，即文件名作为表名，导入数据之前该表必须存在。


OPTIONS 为可选参数选项，其常见的取值如下：

 --fields-terminated-by=value:设置字段之间的分隔符，可以为单个或多个字符，默认情况下为制表符“\t”。
 --fields-enclosed-by=value: 设置字段的包围字符。
 --fields-optionally-enclosed-by=value： 设置字段的包围字符，只能为单个字符，只包括 CHAR 和 VARCHAR 等字符数据字段。
  --fields-escaped-by=value： 控制如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为“\”。
 --lines-terminated-by=value：设置每行数据结尾的字符，可以为单个或多个字符，默认值为“\n”。
--ignore-lines=n： 忽视数据文件的前 n 行

【注】双引号要用转义字符
mysql转义字符
\0
一个ASCII 0 (NUL)字符。
\n
一个新行符。
\t
一个定位符。
\r
一个回车符。
\b
一个退格符。
\ '
一个单引号(“ '”)符。
\ "
一个双引号(“ "”)符。
\\
一个反斜线(“\”)符。
\%
一个“%”符。它用于在正文中搜索“%”的文字实例，否则这里“%”将解释为一个通配符。
\_
一个“_”符。它用于在正文中搜索“_”的文字实例，否则这里“_”将解释为一个通配符。
注意，如果你在某些正文环境中使用“\%”或“\%_”，这些将返回字符串“\%”和“\_”而不是“%”和“_”。

有几种方法在一个字符串内包括引号：

一个字符串内用“ '”加引号的“ '”可以被写作为“ ' '”。
一个字符串内用“ "”加引号的“ "”可以被写作为“ " "”。
你可以把一个转义字符（“\”）放在引号前面。
一个字符串内用“ "”加引号的“ '”不需要特殊对待而且不必被重复或转义。同理，一个字符串内用“ '”加引号的与“ "”也不需要特殊对待。





==================================================================================================================

====================================================MYSQL常用函数==============================================================
current_timestamp() 当前时间戳



route  add 10.0.0.0 mask 255.0.0.0   10.242.103.120