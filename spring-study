1,Spring 在setConfigLocation() 中调用getEnvironment()的createEnvironment()方法创建了两个PropertySource对象 
SystemEnvironmentPropertySource(系统环境变量PATH）  SystemPropertySource（JAVA运行变量）可以通过VMOPTIONS -D来设置具体属性与值.
另外还创建了PropertySourceResolver设置存储PropertySources 并且设置一些属性来方便解析
2,initPropertySource()  来做自己的拓展  比如 setRequiredProeprty(属性值)  可以再后面的valiatedRequiredProperty检验。如果不存在就会抛出异常.
3,初始化xmlDefinaitionReader  设置reader的 DTD方式解析器 BeansDtdResolver  XSD方式解析器 PluggableSchemaResolver meta/spring.schemas存有XSD的名字
4,load 将XML转化为xmlBeanDefinaition
5, 配置文件路径由String --------->String []----------------->Resource[]-------------------------->Resource  
6,xmlDefinaitionReader 采用SAX解析把xml对象先转化为Document对象 对于beans下已有的element做符合自身XSD的处理，
对于自定义element,先根据element.getNamespaceUri方法获取此标签的namespace名称,再根据namespaceUri  到spring.handler文件中找到对应的namespaceHandler
7,找到此element的namespaceHandler后,反射实例化Handler 根据elmentName在Handler里面找到对应的parser
8,根据属性parser将属性和属性值,Class类型转化为对应的BeanDefinition


1.2自定义属性编辑器
1.2.1 首先要有一个自定义属性编辑器,将xml中的propertyValue 按照一定规则转化为相应的对象.
1.2.2 要在属性赋值时调用自定义属性编辑器，填充转换后的属性值.这一步在BeanWrapper当中，所以要将属性编辑器移动到BW当中
1.2.3 为了找到对应的属性的属性编辑器需要CLASS以及PropertyEditor 所以需要PropertyEditorRegistar将两者注入到一个Map当中去
1.2.3 要将属性编辑器移动到BeanWrapper当中，只能先放入BeanFactory.
1.2.4 要将属性编辑器移动到BeanFactory当中，利用BeanFactoryProcessor 在实例化Bean之前做好这些操作，方便实例化，初始化填充属性调用。
1.2.5 Spring 提供了一个CustomConfigureEditor将属性编辑器移动到BeanFactory当中去.所以要先将PropertyEditorRegistar注册到CustomConfigureEditor
或者直接将Class,PropertyEditor放入CustomConfigureEditor里的Map.



2.BeanFacoryPostProcessor(BFP)  BeanFactoryRegistryPostProcessor(BRP)的执行顺序。
2.1 初始化两个容器 一个存在BFP 一个存放BRP  registryBeanFactoryProcessors   regularBeanFactoryProcessors
2.2 存放外部自定义的所有BFP 存放外部自定义的BRP 并且执行BRP自身的实现方法
2.3 获取内部所有的BRP且优先级为PritorOrder的  存放所有的BRP并且执行BRP自身的实现方法。
2.4 获取内部所有的BRP且优先级为Order的的  存放所有的BRP并且执行BRP自身的实现方法.
2.5 循环获取(防止在调用BRP实现方法的同时，注册进来新的BRP!)所有剩下的BRP 存放所有的BRP 并且执行BRP自身的实现方法。
2.6 执行所有BRP从BFP继承的实现方法
2.7 执行外部所有BFP的实现方法
2.9 初始化三个容器 一个存放PO BFP  一个存放OR  BFP  一个存放普通BFP
2.10 获取内部所有的BFP且优先级为PritoryOrder的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.11 获取内部所有的BFP且优先级为Order的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.12 获取内部所有的BFP且优先级为普通的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.12 一次执行内部所有的BFP的实现方法 结束.


3,ConfigurePostBeanProcessor的加载（重点）
3.1 配置文件<context:componentScan>标签 会解析basePackages属性 获取扫描包的路径
3.2 将包下面的类转化为ScanAnnotationBeanDefinition 并且加入BeanDefinitionMap当中去,并且将一些Spring内部的InnerBean自动添加ConfigurationClassPostProcessor，AutowiredAnnotationBeanPostProcessor等等
3.3 后续执行外部BRP的实现方法时，会执行 ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法，进一步执行processConfigBeanDefinitions方法
3.4 processConfigBeanDefinitions方法 会调用ConfigurationClassParser的parse方法对所有的Sbd进行parse();
3.5 parse()方法 doProcessConfigurationClass()方法
3.6 doProcessConfigurationClass() 先判断是否是@Component注解(@Configuration注解组合注解包含了@Component)
3.7 如果是，则processMemberClasses() 继续扫描带有配置注解的内部类
3.8 获取所有带有注解的内部类  再次调用processConfigurationClass（）方法(递归可以解析所有注解修饰的内部类)
3.9 判断是否是@PropertySource注解修饰修饰的类
3.10 如果是加载相应的Properties文件
3.11 判断是否是@ComponentScan注解修饰的类，
3.12 如果是 加载 @ComponentScan  basePackages里面的所有注解修饰的配置类到BeanFactory中去 然后再次调用processConfigBeanDefinitions方法递归解析所有注解配置类





1,spring IOC
xml配置,注解配置
BeanFactory
BeanDefinition

2,spring上下文生命周期
refresh
start
stop
close

2.1 refresh 准备spring上下文阶段 
2.1.1 prepareRefresh()
2.1.2 obtainFreshBeanFactory()
2.1.3 prepareBeanFactory(beanFactory)
2.1.4 postProcessBeanFactory(beanFactory);
2.1.5 invokeBeanFactoryPostProcessors(beanFactory)
2.1.6 registerBeanPostProcessors(beanFactory)
2.1.7 initMessageSource()
2.1.8 onRefresh()
2.1.9 registerListeners()
2.1.10 finishBeanFactoryInitialization(beanFactory)
2.1.11 finishRefresh()



2.2 start

2.3 stop

2.4 close


3,springBean 生命周期

3.1 Bean元信息处理阶段
3.1.1 Bean元信息解析阶段:xml文件 注解 通过相应的BeanDefinitionReader转化成BeanDefinition
3.1.2 Bean注册阶段:将BeanDefinition保存至BeanDefinitionRegistry(典型实现DefaultListableBeanFactory)方便后续调用
3.1.3 BeanDefintion的合并阶段: (具有父类的属性)


3.2 Bean实例化阶段
3.2.1 Bean的Class加载阶段:resolveClass方法会将RootBeanDefinition里面记录的Bean信息加载成Class类保存至RootBeanDefintion里面
3.2.2 Bean的实例化阶段:利用构造器创建Bean
3.2.3 Bean的实例化前阶段:spring提供的Bean拓展方式
3.2.4 Bean的实例化后阶段:spring提供的Bean拓展方式 
3.2.5 Bean的赋值前阶段:?
3.2.6 Bean的赋值阶段




3.3 Bean初始化阶段:
3.3.1 Bean的aware接口回调阶段
3.3.2 Bean的初始化前阶段
3.3.3 Bean的初始化阶段
3.3.4 Bean的初始化后阶段




3.4 Bean销毁阶段
3.4.1 Bean的销毁前阶段
3.4.2 Bean的销毁阶段


3.5 Bean垃圾收集阶段
spring会在上下文关闭后触发GC 触发spring Bean的垃圾收集

4 spring的三级缓存
4.1 singletonObjects  一级
4.2 earlySingletonObjects 二级
4.3 singletonFactories 三级

一级缓存想要进入二级缓存的话，必须满足两个条件 1，一级缓存没有 2，对象正处于创建状态


实例化A------>一到三级缓存检索A,未发现A开始创建A------------>将A转化成ObjectFactory并且放入singleFactories中去
初始化A过程中,发现RunBeanReference B，一到三级缓存中检索B,未发现B，开始创建B
实例化B------------>将B转化成ObjectFactory并且放入singleFactories中去
初始化B过程中,发现RunBeanReference A,一到三级缓存中检索A，发现singleObjectFactory中的beanName,执行ObjectFactory.getObject()方法即getEarlyReference(),如果是代理对象,完成代理对象的创建,由三级缓存singletonFactories移动至二级缓存earlySingletonObjects
初始化B完成,此时B中的属性A已被填充。如果
将初始化后的B由三级缓存移动至一级缓存。
初始化A完成,此时A中的属性B已被填充.
将初始化后的A由二级缓存移动至一级缓存。




5,




