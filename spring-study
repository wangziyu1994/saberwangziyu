1,Spring 在setConfigLocation() 中调用getEnvironment()的createEnvironment()方法创建了两个PropertySource对象 
SystemEnvironmentPropertySource(系统环境变量PATH）  SystemPropertySource（JAVA运行变量）可以通过VMOPTIONS -D来设置具体属性与值.
另外还创建了PropertySourceResolver设置存储PropertySources 并且设置一些属性来方便解析
2,initPropertySource()  来做自己的拓展  比如 setRequiredProeprty(属性值)  可以再后面的valiatedRequiredProperty检验。如果不存在就会抛出异常.
3,初始化xmlDefinaitionReader  设置reader的 DTD方式解析器 BeansDtdResolver  XSD方式解析器 PluggableSchemaResolver meta/spring.schemas存有XSD的名字
4,load 将XML转化为xmlBeanDefinaition
5, 配置文件路径由String --------->String []----------------->Resource[]-------------------------->Resource  
6,xmlDefinaitionReader 采用SAX解析把xml对象先转化为Document对象 对于beans下已有的element做符合自身XSD的处理，
对于自定义element,先根据element.getNamespaceUri方法获取此标签的namespace名称,再根据namespaceUri  到spring.handler文件中找到对应的namespaceHandler
7,找到此element的namespaceHandler后,反射实例化Handler 根据elmentName在Handler里面找到对应的parser
8,根据属性parser将属性和属性值,Class类型转化为对应的BeanDefinition


1.2自定义属性编辑器
1.2.1 首先要有一个自定义属性编辑器,将xml中的propertyValue 按照一定规则转化为相应的对象.
1.2.2 要在属性赋值时调用自定义属性编辑器，填充转换后的属性值.这一步在BeanWrapper当中，所以要将属性编辑器移动到BW当中
1.2.3 为了找到对应的属性的属性编辑器需要CLASS以及PropertyEditor 所以需要PropertyEditorRegistar将两者注入到一个Map当中去
1.2.3 要将属性编辑器移动到BeanWrapper当中，只能先放入BeanFactory.
1.2.4 要将属性编辑器移动到BeanFactory当中，利用BeanFactoryProcessor 在实例化Bean之前做好这些操作，方便实例化，初始化填充属性调用。
1.2.5 Spring 提供了一个CustomConfigureEditor将属性编辑器移动到BeanFactory当中去.所以要先将PropertyEditorRegistar注册到CustomConfigureEditor
或者直接将Class,PropertyEditor放入CustomConfigureEditor里的Map.





1,spring IOC
xml配置,注解配置
BeanFactory
BeanDefinition

2,spring上下文生命周期
refresh
start
stop
close

2.1 refresh 准备spring上下文阶段 
2.1.1 prepareRefresh()
2.1.2 obtainFreshBeanFactory()
2.1.3 prepareBeanFactory(beanFactory)
2.1.4 postProcessBeanFactory(beanFactory);
2.1.5 invokeBeanFactoryPostProcessors(beanFactory)
2.1.6 registerBeanPostProcessors(beanFactory)
2.1.7 initMessageSource()
2.1.8 onRefresh()
2.1.9 registerListeners()
2.1.10 finishBeanFactoryInitialization(beanFactory)
2.1.11 finishRefresh()



2.2 start

2.3 stop

2.4 close


3,springBean 生命周期

3.1 Bean元信息处理阶段
3.1.1 Bean元信息解析阶段:xml文件 注解 通过相应的BeanDefinitionReader转化成BeanDefinition
3.1.2 Bean注册阶段:将BeanDefinition保存至BeanDefinitionRegistry(典型实现DefaultListableBeanFactory)方便后续调用
3.1.3 BeanDefintion的合并阶段:将GenericBeanDefinition转化成RootBeanDefintion(具有父类的属性)


3.2 Bean实例化阶段
3.2.1 Bean的Class加载阶段:resolveClass方法会将RootBeanDefinition里面记录的Bean信息加载成Class类保存至RootBeanDefintion里面
3.2.2 Bean的实例化阶段:利用构造器创建Bean
3.2.3 Bean的实例化前阶段:spring提供的Bean拓展方式
3.2.4 Bean的实例化后阶段:spring提供的Bean拓展方式 
3.2.5 Bean的赋值前阶段:?
3.2.6 Bean的赋值阶段




3.3 Bean初始化阶段:
3.3.1 Bean的aware接口回调阶段
3.3.2 Bean的初始化前阶段
3.3.3 Bean的初始化阶段
3.3.4 Bean的初始化后阶段




3.4 Bean销毁阶段
3.4.1 Bean的销毁前阶段
3.4.2 Bean的销毁阶段


3.5 Bean垃圾收集阶段
spring会在上下文关闭后触发GC 触发spring Bean的垃圾收集

4 spring的三级缓存
4.1 singletonObjects  一级
4.2 earlySingletonObjects 二级
4.3 singletonFactories 三级

一级缓存想要进入二级缓存的话，必须满足两个条件 1，一级缓存没有 2，对象正处于创建状态


实例化A------>一到三级缓存检索A,未发现A开始创建A------------>将A转化成ObjectFactory并且放入singleFactories中去
初始化A过程中,发现RunBeanReference B，一到三级缓存中检索B,未发现B，开始创建B
实例化B------------>将B转化成ObjectFactory并且放入singleFactories中去
初始化B过程中,发现RunBeanReference A,一到三级缓存中检索A，发现singleObjectFactory中的beanName,执行ObjectFactory.getObject()方法即getEarlyReference(),如果是代理对象,完成代理对象的创建,由三级缓存singletonFactories移动至二级缓存earlySingletonObjects
初始化B完成,此时B中的属性A已被填充。如果
将初始化后的B由三级缓存移动至一级缓存。
初始化A完成,此时A中的属性B已被填充.
将初始化后的A由二级缓存移动至一级缓存。




5,




