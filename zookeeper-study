## 1.zookeeper是一个分布式协调服务

##2.zookeeper内部是一个类似文件树的结构。

有根节点，子节点。并且每个节点内可以存储数据。但是不能超过1M。

## 3.zookeeper主从复制模式，一个leader多个follower

leader由选举产生。每个节点都投自己。并且把自己的所有选票投给下一个节点。当票数超过半数。就直接升级为leader

## 4.搭建zookeeper主从复制

####1.zoo.cfg配置

-----------------------------------------------[zoo.cfg 配置说明]---------------------------------------------------------------------------
tickTime：这个时间是作为zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个ticktime时间就会发送一次心跳。

dataDir：顾名思义就是zookeeper保存数据的目录，默认情况下，zookeeper将写数据的日志文件也保存在这个目录里。

clientPort：这个端口号就是客户端连接zkserver服务器的端口，zookeeper会监听这个端口号，接受客户端访问请求。

Initlimit：这个配置项是用来配置zookeeper接受客户端（这里所说的客户端不是用户连接zookeeper服务器的客户端，而是zookeeper服务器集群中连接到leader的follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是ticktime）长度后zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败，总的时间长度就是5*2000=10秒。

Synclimit：这个配置项标示leader与follower之间发送消息，请求和应答时间长度，最长不能超过多少个ticktime的时间长度，总的长度也就是2*2000=4秒。

Server.A=B:C:D：其中A是一个数字，标示这个是第几号服务器；B是这个服务器的ip地址；C标示的是这个服务器与集群中leader服务器交换信息的端口；D表示的是万一集群中的leader服务器挂了，需要一个端口来重新进行选举，选出一个新的leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样的，所以不同的zookeeper实例通信端口号不能一样，所以要给他们分配不同的端口号。

**集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面就有一个数据就是A的值，**

**zookeeper启动时读取此文件，拿到里面的数据zoo.cfg里面的配置信息比较从而判断到底是那个server。**





## 5.zookeper的分布式锁

1. zookeeper createIfnotexist() 可以实现分布式锁，zookeeper分布式锁与redis分布式锁不同的是，zookeeper的锁是和cllient和server的session绑定在一起的。如果zookeeper的锁超时了，那么session也会随之断开. 父节点下可能有多把锁，形成队列式的事务锁。



##6.zookeeper的cid mid pid

| 属性        | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| cZxid       | 创建节点时的事务ID                                           |
| ctime       | 创建节点的时间                                               |
| mZxid       | 最后修改节点时的事务ID                                       |
| mtime       | 最后修改节点时的时间                                         |
| pZxid       | 表示该子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID |
| cversion    | 子节点版本号，子节点每次修改版本号加1                        |
| dataversion | 数据版本号，数据每次修改该版本号加1                          |
| aclversion  | 权限版本号，权限每次修改该版本号加1                          |
| dataLength  | 该节点的数据长度                                             |
| numChildren | 该节点拥有子节点的数量                                       |



## 7.zookeeper 的启动端口的连接，与用途









-----------------------------------------------[zookeeper 命令]---------------------------------------------------------------------------
create node  -e 创建临时节点
stat node 查看节点元数据
delete 删除节点
rmr 递归删除节点
zkServer.sh 启动zkServer.sh脚本   status查看启动状态以及节点角色
zkCli.sh  -server[]

-----------------------------------------------[zookeeper 角色]---------------------------------------------------------------------------
 2.角色：

leader 主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。

follower 子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。

observer 次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。也就是我们的半数原则计算。

observer配置：

只要在集群配置中加上observer后缀即可，示例如下：

server.3=127.0.0.1:2889:3889:observer

------------------------------------------------[zookeeper 选举机制]-------------------------------------------------------------------------
选举机制：

　　先说一个简单的，投票机制的。假设我们现在有1，2，3，4，5五个follower要进行选举。


 简单流程就是这样的，第一轮都认为自己很可以，自己要当选leader，但是选举流程失败了，还得继续，接下来会把自己的票全盘拖出给自己临近的id，1就会给2一票，2现在有了两票了，发现还是不够半数啊，半数是2.5啊，算了还得继续，2又把自己的两票都给了3，3这时获得了3票了，大于半数了，当选leader。

每轮选举结束后都会统一来处理，如果一轮投票就发现server1的zxid较大，那么直接server1会当选leader。

优先检查ZXID。ZXID比较大的服务器优先作为Leader。

如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
